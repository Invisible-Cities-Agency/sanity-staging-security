# Next.js API Contract

This document defines the API contract between the Sanity Studio staging auth bridge and the Next.js application that validates staging access.

## Overview

The staging auth bridge communicates with your Next.js application through two API endpoints to validate user access and manage staging authentication.

## Required API Endpoints

### 1. Validation Endpoint: `/api/auth/validate-sanity-v3`

Validates a user's session and determines their authorization level for staging access.

#### Request

```typescript
POST /api/auth/validate-sanity-v3
Content-Type: application/json

{
  "sessionToken": string,    // Token generated by the auth bridge
  "userRoles": string[],     // User roles from Sanity Studio
  "userName": string,        // Optional: User's display name
  "userEmail": string        // Optional: User's email address
}
```

#### Response

```typescript
// Success (200 OK)
{
  "authorized": boolean,     // Whether the user is authorized
  "role": string,           // User's highest priority role
  "error": string,          // Optional: Error message if not authorized
  "correlationId": string,  // Optional: For request tracking
  "timestamp": string       // Optional: ISO timestamp
}

// Rate Limited (429 Too Many Requests)
Headers:
  Retry-After: number     // Seconds until retry is allowed

// Forbidden (403 Forbidden)
{
  "error": "Access forbidden"
}

// Server Error (500 Internal Server Error)
{
  "error": "Internal server error"
}
```

### 2. Login Endpoint: `/api/auth/staging-login`

Handles the staging login flow when users need to authenticate.

#### Request

```typescript
GET /api/auth/staging-login?returnUrl={encodedUrl}

// Query Parameters:
// - returnUrl: URL-encoded path to return to after login
```

#### Response

Redirect to login page or authentication provider.

## Implementation Example

Here's a basic implementation example for Next.js:

```typescript
// pages/api/auth/validate-sanity-v3.ts
import type { NextApiRequest, NextApiResponse } from 'next'
import { getServerSession } from 'next-auth/react'
import { authOptions } from '../[...nextauth]'

type ValidationRequest = {
  sessionToken: string
  userRoles: string[]
  userName?: string
  userEmail?: string
}

type ValidationResponse = {
  authorized: boolean
  role?: string
  error?: string
  correlationId?: string
  timestamp?: string
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<ValidationResponse>
) {
  // Only accept POST requests
  if (req.method !== 'POST') {
    return res.status(405).json({ 
      authorized: false, 
      error: 'Method not allowed' 
    })
  }

  try {
    const { sessionToken, userRoles, userName, userEmail } = req.body as ValidationRequest

    // Validate the session token format
    if (!sessionToken || !sessionToken.startsWith('studio-validation-')) {
      return res.status(400).json({ 
        authorized: false, 
        error: 'Invalid session token' 
      })
    }

    // Get the current session (example using NextAuth)
    const session = await getServerSession(req, res, authOptions)
    
    if (!session?.user?.email) {
      return res.status(200).json({ 
        authorized: false, 
        error: 'No active session' 
      })
    }

    // Validate user roles and permissions
    // This is where you implement your authorization logic
    const isAuthorized = checkUserAuthorization(session.user, userRoles)
    const userRole = getUserHighestRole(userRoles)

    // Return validation result
    return res.status(200).json({
      authorized: isAuthorized,
      role: userRole,
      timestamp: new Date().toISOString(),
      correlationId: generateCorrelationId()
    })

  } catch (error) {
    console.error('Validation error:', error)
    return res.status(500).json({ 
      authorized: false, 
      error: 'Internal server error' 
    })
  }
}

function checkUserAuthorization(user: any, roles: string[]): boolean {
  // Implement your authorization logic here
  // Example: Check if user has required roles or is in allowed list
  return true // Replace with actual logic
}

function getUserHighestRole(roles: string[]): string {
  // Priority order: administrator > developer > editor > contributor > viewer
  const rolePriority = ['administrator', 'developer', 'editor', 'contributor', 'viewer']
  return roles.find(role => rolePriority.includes(role)) || 'viewer'
}

function generateCorrelationId(): string {
  return `corr-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
}
```

## Security Considerations

### 1. Origin Validation

Always validate the request origin to ensure it's coming from your Sanity Studio:

```typescript
const allowedOrigins = [
  'https://your-studio.sanity.studio',
  'http://localhost:3333' // Development only
]

const origin = req.headers.origin
if (!allowedOrigins.includes(origin)) {
  return res.status(403).json({ 
    authorized: false, 
    error: 'Invalid origin' 
  })
}
```

### 2. Rate Limiting

Implement rate limiting to prevent abuse:

```typescript
import rateLimit from 'express-rate-limit'

const limiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 10, // 10 requests per minute
  handler: (req, res) => {
    res.status(429).json({
      authorized: false,
      error: 'Too many requests'
    })
  }
})

// Apply to your endpoint
export default limiter(handler)
```

### 3. Session Token Validation

- Verify the token format and timestamp
- Consider implementing token expiration
- Log validation attempts for security monitoring

### 4. CORS Configuration

Configure CORS appropriately for your staging environment:

```typescript
// next.config.js
module.exports = {
  async headers() {
    return [
      {
        source: '/api/auth/:path*',
        headers: [
          {
            key: 'Access-Control-Allow-Origin',
            value: 'https://your-studio.sanity.studio'
          },
          {
            key: 'Access-Control-Allow-Methods',
            value: 'POST, OPTIONS'
          },
          {
            key: 'Access-Control-Allow-Headers',
            value: 'Content-Type'
          },
          {
            key: 'Access-Control-Allow-Credentials',
            value: 'true'
          }
        ]
      }
    ]
  }
}
```

## Error Handling

### Standard Error Responses

1. **400 Bad Request**: Invalid request format or missing required fields
2. **403 Forbidden**: Origin not allowed or domain not authorized
3. **429 Too Many Requests**: Rate limit exceeded
4. **500 Internal Server Error**: Unexpected server error

### Error Response Format

All error responses should include:

```typescript
{
  "authorized": false,
  "error": "Human-readable error message",
  "correlationId": "optional-tracking-id"
}
```

## Testing

### Manual Testing

1. Test with valid Sanity Studio session
2. Test with expired or invalid session
3. Test rate limiting behavior
4. Test CORS headers with different origins

### Automated Testing

```typescript
// Example test using Jest
describe('/api/auth/validate-sanity-v3', () => {
  it('should authorize valid session', async () => {
    const response = await fetch('/api/auth/validate-sanity-v3', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        sessionToken: 'studio-validation-123456-abc',
        userRoles: ['administrator'],
        userName: 'Test User',
        userEmail: 'test@example.com'
      })
    })
    
    const data = await response.json()
    expect(response.status).toBe(200)
    expect(data.authorized).toBe(true)
    expect(data.role).toBe('administrator')
  })
})
```

## Monitoring

Consider logging the following for monitoring and debugging:

1. Request volume and response times
2. Authorization success/failure rates
3. Rate limit violations
4. Error rates by type
5. Origin validation failures

## Migration Guide

If you're migrating from an older version:

1. Update endpoint paths if different
2. Add support for new request/response fields
3. Implement proper CORS headers
4. Add rate limiting if not present
5. Update error response format

## Support

For issues or questions about the API contract:

1. Check the [GitHub repository](https://github.com/invisiblecities/sanity-staging-security)
2. Review the [troubleshooting guide](./troubleshooting.md)
3. Open an issue with detailed error logs